Application TaskManagement {
    basePackage=sk.f4s.easytodev

    Module web {

 	    Resource FrontResource {
			String front return="front/overview";
	    }

	    Resource ProjectResource {
             scaffold
        }

        Resource DeploymentResource {
              scaffold
        }

        Resource TaskResource {
             scaffold
        }

        Resource TimeLineResource {
             scaffold
        }

        Resource EndUserResource {
            scaffold
        }

        Resource CommunicationResource {
            scaffold
        }
	}

	Module tasks {

        Entity Project {
            scaffold
            String name;
            String description;
            Date launchDate;  // zaciatok projektu. Vygeneruje sa automaticky v den zapisu do systemu
            - List<@Task> tasks <-> project inverse;

            Repository ProjectRepository {
                findByCondition;
            }
       }

       // ak niekto z developerov alebo operations urobi build v jenkinse a nasadi ho bud do TEST alebo RUT, tak vytvori novy zaznam.
       //ak urobi deployment do testovacieho prostredia, tak vsetkym resolved taskom  sa zmeni placement na TEST
       // ak urobi deploy do RUT, tak vsetky tasky, ktore maju placement TEST, sa im zmeni placement na RUT
       Entity Deployment {
            scaffold
            String label;  // vygeneruje sa automaticky, napr. deployment test
            - @Environment environment;
            Date date;
            - List<@Task> tasks;  // tasky, ktorych sa zmena environment tyka

            Repository DeploymentRepository {
                findByCondition;
            }
       }

       enum Environment {
            DEV, TEST, RUT
       }

       Entity Task {
           scaffold
           - @Project project <-> tasks cascade="persist,merge";  // k akemu projektu patri
           Long projectId;  // kvoli nacitaniu projektu cez localhost
           String name;
           String description;
           - @Type taskType;
           Date originDate;  // datum vzniku ulohy. Vygeneruje sa automaticky v den zapisu do systemu
           - @Priority priority;
           Date deadline;
           - @TaskStatus status;  // stav rozpracovanosti
           - List<@Communication> communications <-> task inverse;
           - List<@TimeLine> timeLines <-> task inverse;  // casovy sled udalosti s taskom
           - @Environment placement; // v akom prostredi je task

           Repository TaskRepository {
              findByCondition;
           }
       }

        enum Type {
           NewFunction, ChangeRequest, Bug, Other;
        }

        enum Priority {
           Urgent, High, Medium, Low;
        }

        enum TaskStatus {
             Created,  // ked klient vytvori novy incident
             Returned, // ked klient vrati zo stavu resolved v prostredi TEST alebo RUT
             Accepted, // developer nastavi ked zacne na nom pracovat na DEV prostredi
             Resolved  // developer nastavi ked ho na DEV prostredi vyriesi
        }

        // historia tasku napr.
        // vytvoreny 1.9.2020 --> v rieseni 8.9.2020 --> vyrieseny 9.9.2020 --> nasadeny Test 1.10.2020 -->
        // vrateny 2.10.2020 --> v rieseni 2.10.2020 --> nasadeny Test 2.10.2010 --> nasadeny RUT 1.12.2020
        Entity TimeLine {
            scaffold
            Date date;
            String label; // kombinacia TaskStatus a Environment a EndUser. Automaticky alebo aj rucne?
            - @EndUser person; // kto zadal
            - @Task task <-> timeLines cascade="persist,merge";  // k akemu tasku patri

            Repository TimeLineRepository {
                findByCondition;
            }
        }

        Entity EndUser {
            scaffold
            String name;
            String role; // este sa doplni viac fieldov

            Repository EndUserRepository {
                 findByCondition;
            }
        }

        Entity Communication {
            scaffold
            - @Task task <-> communications cascade="persist,merge";  // k akemu tasku patri
            Long taskId; // kvoli nacitaniu tasku cez localhost
            - @EndUser sender cascade="persist,merge"; // aby mohli byt dve entity EndUsera pri Communication
            String senderName; // kvoli nacitaniu sendera cez localhost
            - @EndUser recipient cascade="persist,merge";
            String recipientName;  // kvoli nacitaniu sendera cez localhost
            String content;    // vlastna komunikacia
            Date date; // den zapisu do systemu, vygeneruje sa automaticky

            Repository CommunicationRepository {
                findByCondition;
            }
        }

        Service ProjectService {
            findByCondition => ProjectRepository.findByCondition;
        }

        Service DeploymentService {
        // Najprv sa vytvori novy Deployment (ak neexistuje) s pozadovanym environmentom
        // Pridat postupne jednotlive tasky do Deploymentu
        // kontrola, ci vsetky Tasky su v current environmente
        // label --> ready to deploy
        @Deployment addTask(@Task task, @Environment currentEnvironment);

        // Urobit deployment z currentEnvironment do noveho Environment pre vsetky tasky, ktore su ready
        // label --> date + newEnvironment

        @Deployment toDeploy (
            findByCondition => DeploymentRepository.findByCondition;
        }

        Service TaskService {
            findByCondition => TaskRepository.findByCondition;
        }

        Service TimeLineService {
            findByCondition => TimeLineRepository.findByCondition;
        }

        Service EndUserService {
        // najdi usera podla mena
        @EndUser findByName(String name);

        findByCondition => EndUserRepository.findByCondition;
        }

        Service CommunicationService {
        // vsetky komunikacie zoradene zostupne podla casu (od najnovsej po najstarsiu)
        // Vyuzivam pre metodu showAll v resource
        List<@Communication> orderByDateDesc();

        // to iste, ale casovo zoradene vzostupne (od najnovsej)
        List<@Communication> orderByDateAsc();

        // vsetky komunikacie zoradene podla nazvu tasku abc
        List<@Communication> orderByTask();

        // vsetky komunikacie zoradene podla nazvu tasku zyx
        List<@Communication> orderByTaskDesc();

        // komunikacia daneho Tasku zoradena casovo zostupne (od najnovsej po najstarsiu)
        List<@Communication> showByTaskDesc(@Task task);

        // to iste, ale casovo zoradene vzostupne (od najnovsej)
        List<@Communication> showByTaskAsc(@Task task);

        findByCondition => CommunicationRepository.findByCondition;
        }
    }

}
